#!/usr/bin/env node

// inline all custom-tag templates used.
// inline 'if' tags with true conditions if data is supplied.
// inline copies of 'each' tags if data is supplied.
// inline a placeholder comment otherwise.

// allows <img src="{user.avatar}"> without spurious fetch
// uniquifies id attributes inside components (if enabled, unless prefixed with #?)

const htmlparser = require("htmlparser2");
const fs = require('fs');
const path = require('path');
const log = console.log;
const hasOwn = Object.prototype.hasOwnProperty;
const plainDomTag = { anyAttrib:true, params:{} };

const validForScriptImport = {'type':1,'src':1,'tag':1};
const validForTemplateTag = {'tag':1};

const html5 = (
  'html base body head link meta style title '+                                 // document.
  'address article aside footer h1 h2 h3 h4 h5 h6 header hgroup nav section '+  // content.
  'blockquote dd div dl dt figcaption figure hr li main ol p pre ul '+          // text content.
  'a abbr b bdi bdo br cite code data dfn em i kbd mark q rp rt rtc ruby '+     // inline text.
  's samp small span strong sub sup time u var wbr '+
  'area audio img map track video '+ // audio video.
  'embed object param source '+ // embeds.
  'canvas noscript script '+ // scripting.
  'del ins '+ // edits.
  'caption col colgroup table tbody td tfoot th thead tr '+ // table.
  'button datalist fieldset form input label legend meter optgroup option output progress select textarea '+ // forms.
  'details dialog menu menuitem summary '+  // interactive.
  'element shadow slot template ' // web components.
);

const deprecated = (
  'acronym applet basefont big blink center command content dir element '+
  'font frame frameset image isindex keygen listing marquee multicol nextid '+
  'noembed plaintext shadow spacer strike tt xmp'
);

let html5tags = {};
html5.split(' ').forEach(function(tag){ html5tags[tag]=true });

let deprecatedTags = {};
deprecated.split(' ').forEach(function(tag){ deprecatedTags[tag]=true });

let nextId = 0;
function uid() { nextId += 1; return 'm-'+nextId; }

function trim(s) { return s.replace(/^\s\s*/,'').replace(/\s\s*$/,'') }

function normWS(s) {
  return s.replace(/\s+/g, function (ws) { return ws.indexOf("\n") >= 0 ? "\n" : " " });
}

function reconstitute(tag, attribs) {
  let res = '<'+tag;
  for (let i=0, keys=Object.keys(attribs); i<keys.length; i++) {
    let key = keys[i], val = attribs[key];
    res = res + ' ' + key + '="' + val.replace(/"/g,'&quot;') + '"'
  }
  return res; // NB. closing '>' or '/>' is up to the caller.
}

function encodeBinds(binds) {
  let res = '';
  for (let i=0, keys=Object.keys(binds); i<keys.length; i++) {
    let key = keys[i], val = binds[key];
    if (res) res += '; ';
    res = res + key + ':' + val.replace(/"/g,'&quot;');
  }
  return res;
}

function reportUnused(tag, attribs, allow, filename) {
  for (let i=0, keys=Object.keys(attribs); i<keys.length; i++) {
    let key = keys[i];
    if (!hasOwn.call(allow, key)) {
      log('unrecognised "'+key+'" attribute was ignored: '+reconstitute(tag,attribs)+'> in: '+filename);
    }
  }
}

function parseToDOM(source, filename) {
  // Parse the source HTML into a simple DOM tree structure.
  // This handles concerns such as valid tag nesting and self-closing tags.
  let doc = { tag:'#document', attribs:{}, children:[], hasDocType:false };
  let children = doc.children; // collect tags as children of the document.
  let tagStack = [doc];
  const parser = new htmlparser.Parser({
    onopentag: function(tag, attribs) {
      tag = tag.toLowerCase();
      let node = { tag:tag, attribs:attribs, children:[] };
      children.push(node); // include in parent's children.
      tagStack.push(node); // tag is now open.
      children = node.children; // collect tags as children of this node.
    },
    onclosetag: function(tag) {
      tag = tag.toLowerCase();
      if (!tagStack.length) {
        return log('unmatched closing tag </'+tag+'> outside of any open tag in '+filename);
      }
      let openTag = tagStack[tagStack.length-1];
      if (tag == openTag.tag) {
        tagStack.pop();
        let parentTag = tagStack[tagStack.length-1];
        if (!parentTag) {
          // the document should always remain on the stack.
          return log('stack underrun (missing #document) in '+filename);
        }
        children = parentTag.children; // collect tags as children of the parent.
      } else {
        log('unmatched closing tag </'+tag+'> does not match currently open tag <'+openTag.tag+'> in '+filename);
      }
    },
    ontext: function(text) {
      children.push({ tag:'#text', text:text });
    },
    oncdatastart: function() {
      log("lint: CDATA section is deprecated in HTML5, in "+filename);
      children.push({ tag:'#text', text:'<![CDATA[' });
    },
    oncdataend: function() {
      children.push({ tag:'#text', text:']]>' });
    },
    onprocessinginstruction: function(piname, data) {
      if (trim(data).toLowerCase() == '!doctype html') {
        doc.hasDocType = true;
        if (trim(data) != '!DOCTYPE html') {
          log('lint: <!DOCTYPE html> has incorrect upper/lower case in '+filename);
        }
      } else {
        log('lint: ignored processing instruction: <'+piname+' '+data+'> in '+filename);
      }
    },
    onerror: function() {
      // under what conditions will this happen?
      log("parser error:", error);
    }
  }, {decodeEntities: false});
  parser.write(source);
  parser.end();
  while (tagStack.length > 1) { // stop at #document.
    let openTag = tagStack.pop();
    log('lint: unclosed tag <'+openTag.tag+'> in '+filename);
  }
  return doc;
}

function compileExpression(source, where) {
  return { tag:'#expr', expr:source } // TODO.
}

function textTemplate(source, where) {
  // "some {embeds} inside a {text} template."
  // ["some ", {}, " inside a ", {}, " template."]
  let binds = {};
  let nodes = [];
  let spans = source.split('{');
  // ^ ["some ","embeds} inside a ","text} template."]
  let pre = spans[0]; // text before the first '{' (can be empty)
  if (pre) {
    nodes.push(pre); // literal text: normWS(pre)
  }
  for (let i=1; i<spans.length; i++) {
    let span = spans[i]; // e.g. "embeds} inside a "
    let close = span.indexOf('}');
    if (close < 0) {
      log('lint: unclosed "{" in string template '+where);
      close = span.length; // assume at end of span.
    }
    let expr = span.substring(0, close); // text before '}'
    let post = span.substring(close+1); // text after '}'
    nodes.push(compileExpression(expr));
    if (post.length) {
      nodes.push(post); // literal text: normWS(post)
    }
  }
  return { tag:'#text-tpl', nodes:nodes };
}

function parseText(source, where) {
  // recognise the difference between a direct-value binding and a text template.
  // a direct-value binding contains a single expression, e.g. attrib="{ foo }"
  // and will be passed through as a non-string binding object (the receiver might
  // coerce its value to a string however.)
  if (/^\{(.*)\}$/.test(source)) {
    // binding is a single expression: provide it as a direct-value binding.
    return compileExpression(source.substring(1,source.length-1), where);
  } else if (source.indexOf('{') >= 0) {
    // binding is a text template: provide a string-value binding.
    return textTemplate(source, "in attribute '"+key+"' in "+filename);
  } else {
    // attribute has a literal value.
    return { tag:'#text', text:source };
  }
}

function compile(mainFile) {
  let templateCache = {}; // template file -> parsed template object.

  function dummyTemplate() {
    return { tagName:'div', outTag:'div', params:{} }; // TODO: dummy empty template.
  }

  function useTemplate(filename, usedFrom) {
    // Get a compiled template by filename, caching the result.
    let fullPath = path.normalize(path.resolve(path.dirname(usedFrom), filename));
    let tpl = templateCache[fullPath];
    if (tpl.isLoading) {
      let thisImport = usedFrom ? 'from '+usedFrom : 'as the main template';
      let prevImport = tpl.usedFrom ? 'from '+tpl.usedFrom : 'as the main template';
      log('recursive template import: '+filename+' imported '+usedFrom+' and previously '+prevImport);
      return dummyTemplate();
    }
    if (!tpl) {
      templateCache[fullPath] = { isLoading:true, usedFrom:usedFrom };
      tpl = loadTemplate(fullPath, usedFrom);
      templateCache[fullPath] = tpl;
    }
    return tpl;
  }

  function loadTemplate(filename, usedFrom) {
    // Load and compile a template from its source file.
    if (!fs.existsSync(filename)) {
      log('not found: '+filename+(usedFrom ? ' imported from '+usedFrom : ''));
      return dummyTemplate();
    }
    let source = fs.readFileSync(filename, 'utf8');
    let doc = parseToDOM(source, filename);
    if (!usedFrom && !doc.hasDocType) {
      // top-level documents must have a doctype.
      log('lint: missing <!DOCTYPE html> in '+filename);
    }
    // The document must contain a single root node.
    // The tag name of that root node will be the output tag inserted into the document
    // wherever this component is used (unless overridden by tag="foo")
    // strip whitespace text nodes at the beginning and end.
    while (doc.children[0].tag == '#text' && trim(doc.children[0].text).length == 0) doc.children.shift();
    while (doc.children[doc.children.length-1].tag == '#text' && trim(doc.children[doc.children.length-1].text).length == 0) doc.children.pop();
    if (doc.children.length != 1) {
      log('template must contain a single root node (found '+doc.children.length+'): '+filename+(usedFrom ? ' imported from '+usedFrom : ''));
    }
    let customTags = {}; // FIXME: decide how these are scoped.
    customTags['m-store'] = { tagName:'m-store', outTag:'', params:{ name:{} } };
    customTags['m-contents'] = { tagName:'m-contents', outTag:'', params:{} };
    return parseTemplate(doc.children[0], filename, customTags);
  }

  // XXX: decide on the runtime formats here: the template will be compiled as static HTML
  // for the purposes of rendering its initial state or rendering pre-populated views.
  // -> on the client side we need to be able to synthesize dom trees for if/each nodes.
  //    generate a doc-fragment template for each one on the client-side? [many ways, pick one!]
  //    avoid adjacent comments. use empty text nodes as placeholders.

  // server-side rendering: ideally we want something of the form:
  // return ['<!DOCTYPE html><html><body><div>', esc(.. generated data expr ..), '</div></body></html>'].join('');

  // client-side rendering: walk a flat array of the form:
  // [tag-idx, tpl-idx, n-stat, ( name-idx, val-idx ), n-bind, ( name-idx, binder-idx ), n-child, ( data for n children ... ) ]
  // tag-idx is into a table of DOM node types and re-use lists of same.
  // tpl-idx is into a list of template bind functions (custom tag controllers)

  function parseTemplate(rootNode, filename, customTags) {
    // Walk template DOM and parse out custom tag and attribute bindings.
    // Have: compiled templates, their params and param types.
    // Need: compiled template with params, resolved imports, parsed binding expressions.
    let tplTag = rootNode.tag;
    let tpl = {
      tagName: tplTag, // the root node is the custom-tag name (unless overridden at the import site)
      outTag: rootNode.attribs['tag'] || tplTag, // the output tag can be different from the custom-tag.
      params: {},
      nodes: []
    };
    // parse all the template parameters.
    for (let i=0, keys=Object.keys(rootNode.attribs); i<keys.length; i++) {
      let key = keys[i], val = rootNode.attribs[key];
      if (key.match(/^in-/)) {
        tpl.params[key.substr(3)] = val;
      }
    }
    function walkNodes(node, outNodes, where) {
      let tag = node.tag, attribs = node.attribs;
      if (!tag) throw new Error("no: "+JSON.stringify(node));
      if (tag === "import") {

        // import tag (elided from output)
        if (!attribs.src) {
          return log('missing "src" attribute on template import: '+reconstitute(tag,attribs)+'> in: '+filename);
        }
        let tpl = useTemplate(attribs.src, filename);
        let tagName = attribs['tag'] || attribs['m-tag'] || tpl.tagName; // allow local custom-tag name override.
        if (!tagName) {
          return log('missing tag name (m-tag) on imported: '+reconstitute(tag,attribs)+'> in: '+filename);
        }
        if (customTags[tagName]) {
          return log('duplicate custom tag name "'+tagName+'" imported: '+reconstitute(tag,attribs)+'> in: '+filename);
        }
        customTags[tagName] = tpl;
        reportUnused(tag, attribs, validForScriptImport, filename);
        if (children.length) {
          log('import tag cannot have children: '+reconstitute(tag,attribs)+'> in: '+filename);
        }

      } else if (tag == "component" || tag == "template") {

        // inline template tag (elided from output)
        let tagName = attribs['tag'] || attribs['m-tag'];
        if (!tagName) {
          return log('missing tag name (m-tag) on declared: '+reconstitute(tag,attribs)+'> in: '+filename);
        }
        if (customTags[tagName]) {
          return log('duplicate custom tag name "'+tagName+'" on declared: '+reconstitute(tag,attribs)+'> in: '+filename);
        }
        // make a root node for parseTemplate with the tag name as the root node.
        let tplRoot = { tag:tagName, attribs:attribs, children:node.children, hasDocType:false };
        let tpl = parseTemplate(tplRoot, filename, customTags);
        customTags[tagName] = tpl;

      } else if (tag == '#text') {

        // parse any embedded expressions in the text content.
        outNodes.push(parseText(node.text, 'text node in '+where));

      } else {

        // template import can be placed on the tag itself (elided from output)
        if (attribs['m-import']) {
          let tpl = useTemplate(attribs['m-import'], filename);
          if (!tpl.tagName) throw new Error("missing tagName");
          if (customTags[tpl.tagName]) {
            return log('duplicate custom tag name "'+tagName+'" imported: '+reconstitute(tag,attribs)+'> in: '+filename);
          }
          customTags[tpl.tagName] = tpl; // no tag-name override on inline import.
        }

        // resolve custom tag to its template so we can recognise its parameters.
        // warn if it's not a standard html tag and doesn't match a custom template.
        // TODO: find imports as a pre-pass, so import can be after the first use.
        let tpl = customTags[tag];
        if (!tpl) {
          if (!hasOwn.call(html5tags, tag)) {
            // not a valid HTML5 tag.
            if (hasOwn.call(deprecatedTags, tag)) {
              log('lint: tag is deprecated in HTML5: '+reconstitute(tag,attribs)+'> in: '+filename);
            } else {
              log('unrecognised custom tag '+reconstitute(tag,attribs)+'> in: '+filename);
            }
          }
          tpl = plainDomTag;
        }

        // find all attributes that contain a binding expression and compile those expressions.
        // warn if it's not a standard html attribute and doesn't match a custom attribute.
        // also warn if it is a standard attribute on a tag that doesn't allow those.
        let params = tpl.params, anyAttrib = tpl.anyAttrib;
        let binds = {};
        for (let i=0, keys=Object.keys(attribs); i<keys.length; i++) {
          let key = keys[i], val = attribs[key];
          let pb = params[key];
          if (!pb && !anyAttrib) {
            log('unrecognised "'+key+'" attribute on tag: '+reconstitute(tag,attribs)+'> in: '+filename);
          }
          binds[key] = parseText(val, "in attribute '"+key+"' of "+reconstitute(tag,attribs)+"> in "+filename);
        }

        // walk child nodes recursively and perform all the same parsing steps.
        // TODO: for custom tags, capture content for transclude or warn unused content.
        let children = node.children;
        let nodes = [];
        if (children) {
          for (let i=0; i<children.length; i++) {
            let child = children[i];
            let result = walkNodes(child, nodes, where);
          }
        }

        outNodes.push({ tag:tag, tpl:tpl, binds:binds, nodes:nodes });
      }
    }
    walkNodes(rootNode, tpl.nodes, filename);
    return tpl;
  }

  return loadTemplate(mainFile);
}

function compileTarget(filename) {
  const decl = compile(filename);
  fs.writeFileSync('out/index.json', JSON.stringify(decl,null,2), 'utf8');
  //fs.writeFileSync('out/index.html', JSON.stringify(decl,null,2), 'utf8');
  //fs.writeFileSync('out/binds.js', JSON.stringify(decl.binds), 'utf8');
}

compileTarget(process.argv[2]);
