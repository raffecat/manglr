#!/usr/bin/env node

// inline all custom-tag templates used.
// inline 'if' tags with true conditions if data is supplied.
// inline copies of 'each' tags if data is supplied.
// inline a placeholder comment otherwise.

// allows <img src="{user.avatar}"> without spurious fetch
// uniquifies id attributes inside components (if enabled, unless prefixed with #?)

const htmlparser = require("htmlparser2");
const fs = require('fs');
const path = require('path');
const log = console.log;
const hasOwnProperty = Object.prototype.hasOwnProperty;
const plainDomTag = { anyAttrib:true, params:{} };

const validForScriptImport = {'type':1,'src':1,'tag':1};
const validForTemplateTag = {'tag':1};

let nextId = 0;
function uid() { nextId += 1; return 'm-'+nextId; }

function trim(s) { return s.replace(/^\s\s*/,'').replace(/\s\s*$/,'') }

function normWS(s) {
  return s.replace(/\s+/g, function (ws) { return ws.indexOf("\n") >= 0 ? "\n" : " " });
}

function reconstitute(tag, attribs) {
  let res = '<'+tag;
  for (let i=0, keys=Object.keys(attribs); i<keys.length; i++) {
    let key = keys[i], val = attribs[key];
    res = res + ' ' + key + '="' + val.replace(/"/g,'&quot;') + '"'
  }
  return res; // NB. closing '>' or '/>' is up to the caller.
}

function encodeBinds(binds) {
  let res = '';
  for (let i=0, keys=Object.keys(binds); i<keys.length; i++) {
    let key = keys[i], val = binds[key];
    if (res) res += '; ';
    res = res + key + ':' + val.replace(/"/g,'&quot;');
  }
  return res;
}

function reportUnused(tag, attribs, allow, filename) {
  for (let i=0, keys=Object.keys(attribs); i<keys.length; i++) {
    let key = keys[i];
    if (!hasOwnProperty.call(allow, key)) {
      log('unrecognised "'+key+'" attribute was ignored: '+reconstitute(tag,attribs)+'> in: '+filename);
    }
  }
}

function parseToDOM(source, filename) {
  // Parse the source HTML into a simple DOM tree structure.
  // This handles concerns such as valid tag nesting and self-closing tags.
  let doc = { tag:'#document', attribs:{}, children:[], hasDocType:false };
  let children = doc.children; // collect tags as children of the document.
  let tagStack = [doc];
  const parser = new htmlparser.Parser({
    onopentag: function(tag, attribs) {
      tag = tag.toLowerCase();
      let node = { tag:tag, attribs:attribs, children:[] };
      children.push(node); // include in parent's children.
      tagStack.push(node); // tag is now open.
      children = node.children; // collect tags as children of this node.
    },
    onclosetag: function(tag) {
      tag = tag.toLowerCase();
      if (!tagStack.length) {
        return log('unmatched closing tag </'+tag+'> outside of any open tag in '+filename);
      }
      let openTag = tagStack[tagStack.length-1];
      if (tag == openTag.tag) {
        tagStack.pop();
        let parentTag = tagStack[tagStack.length-1];
        if (!parentTag) {
          // the document should always remain on the stack.
          return log('stack underrun (missing #document) in '+filename);
        }
        children = parentTag.children; // collect tags as children of the parent.
      } else {
        log('unmatched closing tag </'+tag+'> does not match currently open tag <'+openTag.tag+'> in '+filename);
      }
    },
    ontext: function(text) {
      children.push({ tag:'#text', text:text });
    },
    oncdatastart: function() {
      log("lint: CDATA section is deprecated in HTML5, in "+filename);
      children.push({ tag:'#text', text:'<![CDATA[' });
    },
    oncdataend: function() {
      children.push({ tag:'#text', text:']]>' });
    },
    onprocessinginstruction: function(piname, data) {
      if (trim(data).toLowerCase() == '!doctype html') {
        doc.hasDocType = true;
        if (trim(data) != '!DOCTYPE html') {
          log('lint: <!DOCTYPE html> has incorrect upper/lower case in '+filename);
        }
      } else {
        log('lint: ignored processing instruction: <'+piname+' '+data+'> in '+filename);
      }
    },
    onerror: function() {
      // under what conditions will this happen?
      log("parser error:", error);
    }
  }, {decodeEntities: false});
  parser.write(source);
  parser.end();
  while (tagStack.length > 1) { // stop at #document.
    let openTag = tagStack.pop();
    log('lint: unclosed tag <'+openTag.tag+'> in '+filename);
  }
  return doc;
}

function compileExpression(source, where) {
  return { expr:source } // TODO.
}

function textTemplate(source, where) {
  // "some {embeds} inside a {text} template."
  // ["some ", {}, " inside a ", {}, " template."]
  let binds = {};
  let nodes = [];
  let spans = source.split('{');
  // ^ ["some ","embeds} inside a ","text} template."]
  let pre = spans[0]; // text before the first '{' (can be empty)
  if (pre) {
    nodes.push(pre); // literal text: normWS(pre)
  }
  for (let i=1; i<spans.length; i++) {
    let span = spans[i]; // e.g. "embeds} inside a "
    let close = span.indexOf('}');
    if (close < 0) {
      log('lint: unclosed "{" in string template '+where+' in '+filename);
      close = span.length; // assume at end of span.
    }
    let expr = span.substring(0, close); // text before '}'
    let post = span.substring(close+1); // text after '}'
    nodes.push(compileExpression(expr));
    if (post.length) {
      nodes.push(post); // literal text: normWS(post)
    }
  }
  return { tag:false, nodes:nodes };
}

function parseBinding(source) {
  return { source:source } // TODO. provide some indicative output.
}

function compile(mainFile) {
  let templateCache = {}; // template file -> parsed template object.

  function dummyTemplate() {
    return { tagName:'div', outTag:'div', params:{} }; // TODO: dummy empty template.
  }

  function useTemplate(filename, usedFrom) {
    // Get a compiled template by filename, caching the result.
    let fullPath = path.normalize(path.resolve(path.dirname(usedFrom), filename));
    let tpl = templateCache[fullPath];
    if (tpl.isLoading) {
      let thisImport = usedFrom ? 'from '+usedFrom : 'as the main template';
      let prevImport = tpl.usedFrom ? 'from '+tpl.usedFrom : 'as the main template';
      log('recursive template import: '+filename+' imported '+usedFrom+' and previously '+prevImport);
      return dummyTemplate();
    }
    if (!tpl) {
      templateCache[fullPath] = { isLoading:true, usedFrom:usedFrom };
      tpl = loadTemplate(fullPath, usedFrom);
      templateCache[fullPath] = tpl;
    }
    return tpl;
  }

  function loadTemplate(filename, usedFrom) {
    // Load and compile a template from its source file.
    if (!fs.existsSync(filename)) {
      log('not found: '+filename+(usedFrom ? ' imported from '+usedFrom : ''));
      return dummyTemplate();
    }
    let source = fs.readFileSync(filename, 'utf8');
    let doc = parseToDOM(source, filename);
    if (!usedFrom && !doc.hasDocType) {
      // top-level documents must have a doctype.
      log('lint: missing <!DOCTYPE html> in '+filename);
    }
    // The document must contain a single root node.
    // The tag name of that root node will be the output tag inserted into the document
    // wherever this component is used (unless overridden by tag="foo")
    // strip whitespace text nodes at the beginning and end.
    log(doc.children[0].tag, doc.children[1].tag, doc.children[2].tag);
    while (doc.children[0].tag == '#text' && trim(doc.children[0].text).length == 0) doc.children.shift();
    while (doc.children[doc.children.length-1].tag == '#text' && trim(doc.children[doc.children.length-1].text).length == 0) doc.children.pop();
    if (doc.children.length != 1) {
      log('template must contain a single root node (found '+doc.children.length+'): '+filename+(usedFrom ? ' imported from '+usedFrom : ''));
    }
    return parseTemplate(doc.children[0], filename);
  }

  // XXX: decide on the runtime formats here: the template will be compiled as static HTML
  // for the purposes of rendering its initial state or rendering pre-populated views.
  // -> on the client side we need to be able to synthesize dom trees for if/each nodes.
  //    generate a doc-fragment template for each one on the client-side? [many ways, pick one!]
  //    avoid adjacent comments. use empty text nodes as placeholders.

  // server-side rendering: ideally we want something of the form:
  // return ['<!DOCTYPE html><html><body><div>', esc(.. generated data expr ..), '</div></body></html>'].join('');

  // client-side rendering: walk a flat array of the form:
  // [tag-idx, tpl-idx, n-stat, ( name-idx, val-idx ), n-bind, ( name-idx, binder-idx ), n-child, ( data for n children ... ) ]
  // tag-idx is into a table of DOM node types and re-use lists of same.
  // tpl-idx is into a list of template bind functions (custom tag controllers)

  function parseTemplate(rootNode, filename, customTags) {
    // Walk template DOM and parse out custom tag and attribute bindings.
    // Have: compiled templates, their params and param types.
    // Need: compiled template with params, resolved imports, parsed binding expressions.
    let tplTag = rootNode.tag;
    let tpl = {
      tagName: tplTag, // the root node is the custom-tag name (unless overridden at the import site)
      outTag: rootNode.attribs['tag'] || tplTag // the output tag can be different from the custom-tag.
    };
    // parse all the template parameters.
    tpl.params = {};
    for (let i=0, keys=Object.keys(rootNode.attribs); i<keys.length; i++) {
      let key = keys[i], val = rootNode.attribs[key];
      if (key.match(/^in-/)) {
        tpl.params[key.substr(3)] = val;
      }
    }
    function walkTemplate(tag, attribs, children, outerWhere) {
      if (tag === "import") {
        // import tag (elided from output)
        if (!attribs.src) {
          return log('missing "src" attribute on template import: '+reconstitute(tag,attribs)+'> in: '+filename);
        }
        let tpl = useTemplate(attribs.src, filename);
        let tagName = attribs['tag'] || tpl.tagName; // allow local custom-tag name override.
        if (custom_tags[tagName]) {
          return log('duplicate custom tag name "'+tagName+'" imported: '+reconstitute(tag,attribs)+'> in: '+filename);
        }
        custom_tags[tagName] = tpl;
        reportUnused(tag, attribs, validForScriptImport, filename);
        if (children.length) {
          log('import tag cannot have children: '+reconstitute(tag,attribs)+'> in: '+filename);
        }
      } else if (tag == "component") {
        // inline template tag (elided from output)
        let tagName = attribs['tag'];
        if (custom_tags[tagName]) {
          return log('duplicate custom tag name "'+tagName+'" on declared: '+reconstitute(tag,attribs)+'> in: '+filename);
        }
        // make a root node for parseTemplate with the tag name as the root node.
        let tplRoot = { tag:tagName, attribs:attribs, children:children, hasDocType:false };
        let tpl = parseTemplate(tplRoot, filename);
        custom_tags[tagName] = tpl;
      } else if (tag == '#text') {
        // parse any embedded expressions in the text content.
        return textTemplate(attribs.text, outerWhere);
      } else {
        // template import can be placed on the tag itself (elided from output)
        if (attribs['m-import']) {
          let tpl = useTemplate(attribs['m-import'], filename);
          if (custom_tags[tpl.tagName]) {
            return log('duplicate custom tag name "'+tagName+'" imported: '+reconstitute(tag,attribs)+'> in: '+filename);
          }
          custom_tags[tpl.tagName] = tpl; // no tag-name override on inline import.
        }
        // resolve custom tag to its template so we can recognise its parameters.
        // warn if it's not a standard html tag and doesn't match a custom template.
        let tpl = custom_tags[tag];
        if (!tpl) {
          if (tag.indexOf('-') >= 0) { // TODO: use a map of valid HTML tags.
            log('unrecognised custom tag '+reconstitute(tag,attribs)+'> in: '+filename);
          }
          tpl = plainDomTag;
        }
        // find all attributes that contain a binding expression and compile those expressions.
        // warn if it's not a standard html attribute and doesn't match a custom attribute.
        // also warn if it is a standard attribute on a tag that doesn't allow those.
        let params = tpl.params, anyAttrib = tpl.anyAttrib;
        let stat = {}, binds = {};
        for (let i=0, keys=Object.keys(attribs); i<keys.length; i++) {
          let key = keys[i], val = attribs[key];
          let pb = params[key];
          if (!pb && !anyAttrib) {
            log('unrecognised "'+key+'" attribute on tag: '+reconstitute(tag,attribs)+'> in: '+filename);
          }
          // recognise the difference between a direct-value binding and a text template.
          // a direct-value binding contains a single expression, e.g. attrib="{ foo }"
          // and will be passed through as a non-string binding object (the receiver might
          // coerce its value to a string however.)
          if (/^\{[^{}]*\}$/.test(val)) {
            // binding is a single expression: provide it as a direct binding argument.
            binds[key] = compileExpression(val.substring(1,val.length-1), where);
          } else if (val.indexOf('{') >= 0) {
            // binding is a text template: provide a string-valued binding.
            binds[key] = textTemplate(val, params);
          } else {
            // attribute has a literal value.
            stat[key] = val;
          }
        }
        // walk child nodes recursively and perform all the same steps.
        // TODO: for custom tags, capture content for transclude or warn unused content.
        // TODO: actually we have the compiled tag-tpl here, so why not inline it and resolve used attributes?
        // TODO: we also need to determine if/each nodes and make spawnable templates for those.
        let nodes = [];
        for (let i=0; i<children.length; i++) {
          let child = children[i];
          let result = walkTemplate(child.tag, child.attribs, child.children);
          // child nodes can be elided during parsing.
          if (result != null) {
            nodes.push(result);
          }
        }
        return { tag:true, tpl:tpl, stat:stat, binds:binds, nodes:nodes };
      }
    }
    tpl.nodes = walkTemplate(rootNode.tag, rootNode.attribs, rootNode.children);
    return tpl;
  }

  /*
  function parseHTML(filename, usedFrom, isRoot) {
    // parse HTML template and generate json-dom.
    let custom_tags = {}; // templates imported in this file (might want locals for inline templates)
    let template_stack = []; // stack of inline 'template' tags being parsed.
    let decl = {
      tagName: path.posix.basename(filename).replace(/\.[^\.]+$/,'').toLowerCase(), // default if not declared within this template.
      outTag: 'div', // root tag to output for this tempate.
      params: {}, // declared within this template.
      dom: [], // output dom nodes in this decl.
      tagStack: [], // currently open tags.
      binds: {}
    }
    // TODO: recognise tag="foo" (or use root tag name) and any m-params on the root tag of the template.
    let dom = decl.dom; // cached decl.dom.
    let tagStack = decl.tagStack; // cached decl.tagStack.
    if (isRoot) {
      dom.push('<!DOCTYPE html>');
    }
    const parser = new htmlparser.Parser({
      onopentag: function(tag, attribs) {
        tag = tag.toLowerCase(); // all html and custom tags are mapped to lower-case.
        log("O "+tag);
        let stat = {};
        let binds = {};
        if (tag === "script" && attribs.type === "manglr/tag") {
        } else {
        tagStack.push({ tag:tag, line:1 }); // TODO: line numbers!
      },
      onclosetag: function(tag) {
        log("C "+tag);
        if (!tagStack.length) {
          return log('unmatched closing tag </'+tag+'> outside of any open tag in '+filename);
        }
        let openTag = tagStack[tagStack.length-1].tag;
        if (tag == openTag) {
          tagStack.pop();
        } else {
          return log('unmatched closing tag </'+tag+'> does not match currently open tag <'+openTag+'> in '+filename);
        }
        if (tag == 'template') {
          decl = template_stack.pop();
          dom = decl.dom; // cached decl.dom.
          tagStack = decl.tagStack; // cached decl.tagStack.
        } else {
          dom.push('</'+tag+'>');
        }
      },
      ontext: function(val) {
      },
      onerror: function() {
        log("parser error:", error);
      },
      oncomment: function(data) {
        log("comment: "+data);
      },
      oncdatastart: function() {
        log("warning: CDATA section is deprecated in HTML5, in "+filename);
        dom.push('<![CDATA[');
      },
      oncdataend: function() {
        dom.push(']]>');
      },
      onprocessinginstruction: function(piname, data) {
        if (trim(data).toLowerCase() == '!doctype html') {
          if (trim(data) != '!DOCTYPE html') {
            log('lint: <!DOCTYPE html> has incorrect upper/lower case in '+filename);
          }
          foundDocType = true;
        } else {
          log('ignored processing instruction: <'+piname+' '+data+'> in '+filename);
        }
      }
    }, {decodeEntities: false});

    // read and parse the source file.
    if (!fs.existsSync(filename)) {
      log('not found: '+filename+(usedFrom ? ' imported from '+usedFrom : ''));
      return decl;
    }
    let source = fs.readFileSync(filename, 'utf8');
    let dom = parseToDOM(source, filename);
    if (isRoot) {
      if (!dom.hasDocType) {
        log('lint: missing <!DOCTYPE html> in '+filename);
      }
    }
    return decl;
  }
  return parseHTML(mainFile, null, true);
  */

  return loadTemplate(mainFile);
}

function compileTarget(filename) {
  const decl = compile(filename);
  fs.writeFileSync('out/index.html', decl.dom.join(''), 'utf8');
  fs.writeFileSync('out/binds.js', JSON.stringify(decl.binds), 'utf8');
}

compileTarget(process.argv[2]);
